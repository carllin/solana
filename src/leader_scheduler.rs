//! The `leader_scheduler` module implements a structure and functions for tracking and
//! managing the schedule for leader rotation

use bank::Bank;
use bincode::serialize;
use byteorder::{LittleEndian, ReadBytesExt};
use hash::hash;
use signature::Pubkey;
use std::collections::HashMap;
use std::io::Cursor;

pub const ACTIVE_WINDOW: u64 = 5000;

struct ActiveValidators {
    // Map from validator id to the last entry height at which they voted,
    active_validators: HashMap<Pubkey, u64>,
}

impl ActiveValidators {
    pub fn new() -> Self {
        ActiveValidators {
            active_validators: HashMap::new(),
        }
    }

    // Finds all the active voters who have voted in the range
    // (entry_height - ACTIVE_WINDOW, entry_height], and removes
    // anybody who hasn't voted in that range from the map
    pub fn get_active_set(&mut self, entry_height: u64) -> Vec<Pubkey> {
        let lower_bound = entry_height.saturating_sub(ACTIVE_WINDOW);
        self.active_validators
            .retain(|_, entry_height| *entry_height > lower_bound);
        self.active_validators.keys().cloned().collect()
    }

    // Push a vote for a validator with id == "id" who voted at entry height == "entry_height"
    pub fn push_vote(&mut self, id: Pubkey, entry_height: u64) -> () {
        let old_height = self.active_validators.entry(id).or_insert(entry_height);
        if entry_height > *old_height {
            *old_height = entry_height;
        }
    }
}

pub struct LeaderScheduler {
    // The interval at which to rotate the leader, should be much less than
    // seed_rotation_interval
    pub leader_rotation_interval: u64,

    // The interval at which to generate the seed used for ranking the validators
    pub seed_rotation_interval: u64,

    // The first leader who will bootstrap the network
    pub bootstrap_leader: Pubkey,

    // The last entry height at which the bootstrap_leader will be in power before
    // the leader rotation process begins to pick future leaders
    pub bootstrap_entry_height: u64,

    // Maintain the set of active validators
    active_validators: ActiveValidators,

    // Round-robin ordering for the validators
    pub leader_schedule: Vec<Pubkey>,

    // The last entry height at which the seed was generated
    last_seed_entry_height: Option<u64>,

    // The seed used to determine the round robin order of leaders
    seed: u64,
}

impl LeaderScheduler {
    pub fn new(
        bootstrap_leader: Pubkey,
        bootstrap_entry_height_option: Option<u64>,
        leader_rotation_interval_option: Option<u64>,
        seed_rotation_interval_option: Option<u64>,
    ) -> Self {
        let mut bootstrap_entry_height = 1000;
        if let Some(input) = bootstrap_entry_height_option {
            bootstrap_entry_height = input;
        }

        let mut leader_rotation_interval = 100;
        if let Some(input) = leader_rotation_interval_option {
            leader_rotation_interval = input;
        }

        let mut seed_rotation_interval = 1000;
        if let Some(input) = seed_rotation_interval_option {
            seed_rotation_interval = input;
        }

        assert!(seed_rotation_interval > leader_rotation_interval);
        assert!(bootstrap_entry_height > 0);
        assert!(seed_rotation_interval % leader_rotation_interval == 0);

        LeaderScheduler {
            active_validators: ActiveValidators::new(),
            leader_rotation_interval,
            seed_rotation_interval,
            leader_schedule: Vec::new(),
            last_seed_entry_height: None,
            bootstrap_leader,
            bootstrap_entry_height,
            seed: 0,
        }
    }

    pub fn push_vote(&mut self, id: Pubkey, entry_height: u64) {
        self.active_validators.push_vote(id, entry_height);
    }

    fn get_active_set(&mut self, entry_height: u64) -> Vec<Pubkey> {
        self.active_validators.get_active_set(entry_height)
    }

    pub fn update_entry_height(&mut self, entry_height: u64, bank: &Bank) {
        if entry_height % self.seed_rotation_interval == 0 {
            self.generate_schedule(entry_height, bank);
        }
    }

    // Uses the schedule generated by the last call to generate_schedule() to return the
    // leader for a given entry height in round-robin fashion
    pub fn get_scheduled_leader(&self, entry_height: u64) -> Option<Pubkey> {
        // This covers cases where the schedule isn't yet generated.
        if self.last_seed_entry_height == None {
            if entry_height < self.bootstrap_entry_height {
                return Some(self.bootstrap_leader);
            } else {
                // If there's been no schedule generated yet before we reach the end of the
                // bootstrapping period, then the leader is unknown
                return None;
            }
        }

        // If we have a schedule, then just check that we are within the bounds of that
        // schedule [last_seed_entry_height, last_seed_entry_height + seed_rotation_interval).
        // Leaders outside of this bound are undefined.
        let last_seed_entry_height = self.last_seed_entry_height.unwrap();
        if entry_height >= last_seed_entry_height + self.seed_rotation_interval
            || entry_height < last_seed_entry_height
        {
            return None;
        }

        // Find index into the leader_schedule that this entry height maps to
        let index = (entry_height - last_seed_entry_height) / self.leader_rotation_interval;
        let validator_index = index as usize % self.leader_schedule.len();
        Some(self.leader_schedule[validator_index])
    }

    // Called every seed_rotation_interval entries, generates the leader schedule
    // for the range of entries: [entry_height, entry_height + seed_rotation_interval)
    fn generate_schedule(&mut self, entry_height: u64, bank: &Bank) {
        let seed = Self::calculate_seed(entry_height);
        self.seed = seed;
        let active_set = self.get_active_set(entry_height);
        let ranked_active_set = Self::rank_active_set(bank, active_set);

        // Handle case where there are no active validators with
        // non-zero stake. In this case, use the bootstrap leader for
        // the upcoming rounds
        if ranked_active_set.is_empty() {
            self.leader_schedule = vec![self.bootstrap_leader];
            return;
        }

        let (mut validator_rankings, total_tokens) = ranked_active_set.iter().fold(
            (Vec::with_capacity(ranked_active_set.len()), 0),
            |(mut ids, total_tokens), (pk, tokens)| {
                ids.push(*pk);
                (ids, total_tokens + *tokens)
            },
        );

        let ranked_accounts = ranked_active_set.into_iter().map(|(_, tokens)| tokens);
        let start_index = Self::choose_account(ranked_accounts, self.seed, total_tokens);
        validator_rankings.rotate_left(start_index + 1);

        // There are only seed_rotation_interval / self.leader_rotation_interval slots, so
        // we only need to keep at most that many validators in the schedule
        validator_rankings
            .truncate((self.seed_rotation_interval / self.leader_rotation_interval) as usize);
        self.leader_schedule = validator_rankings;
        self.last_seed_entry_height = Some(entry_height);
    }

    fn rank_active_set(bank: &Bank, active: Vec<Pubkey>) -> Vec<(Pubkey, u64)> {
        let bank_accounts = bank.accounts.read().unwrap();
        let mut active_accounts: Vec<(Pubkey, u64)> = active
            .into_iter()
            .filter_map(|pk| {
                bank_accounts
                    .get(&pk)
                    .filter(|account| account.tokens > 0)
                    .map(|account| (pk, account.tokens as u64))
            }).collect();

        active_accounts.sort_by(
            |(pk1, t1), (pk2, t2)| {
                if t1 == t2 {
                    pk1.cmp(&pk2)
                } else {
                    t1.cmp(&t2)
                }
            },
        );
        active_accounts
    }

    fn calculate_seed(entry_height: u64) -> u64 {
        let bytes = hash(&serialize(&entry_height).unwrap()).0;
        let mut rdr = Cursor::new(bytes);
        rdr.read_u64::<LittleEndian>().unwrap()
    }

    fn choose_account<I>(tokens: I, seed: u64, total_tokens: u64) -> usize
    where
        I: IntoIterator<Item = u64>,
    {
        let mut total = 0;
        let mut chosen_account = 0;
        let seed = seed % total_tokens;
        for (i, tokens) in tokens.into_iter().enumerate() {
            // We should have filtered out all accounts with zero token balances in
            // rank_active_set()
            assert!(tokens != 0);
            total += tokens;
            if total > seed {
                chosen_account = i;
                break;
            }
        }

        chosen_account
    }
}

#[cfg(test)]
mod tests {
    use bank::Bank;
    use leader_scheduler::{LeaderScheduler, ACTIVE_WINDOW};
    use mint::Mint;
    use signature::{Keypair, KeypairUtil, Pubkey};
    use std::collections::HashSet;
    use std::hash::Hash;
    use std::iter::FromIterator;

    fn to_hashset<T>(slice: &[T]) -> HashSet<&T>
    where
        T: Eq + Hash,
    {
        HashSet::from_iter(slice.iter())
    }

    fn to_hashset_owned<T>(slice: &[T]) -> HashSet<T>
    where
        T: Eq + Hash + Clone,
    {
        HashSet::from_iter(slice.iter().cloned())
    }

    #[test]
    fn test_active_set() {
        let leader_id = Keypair::new().pubkey();
        let mut leader_scheduler = LeaderScheduler::new(leader_id, Some(100), Some(100), Some(100));

        // Insert a bunch of votes at height "start_height"
        let start_height = 3;
        let num_old_ids = 20;
        let mut old_ids = HashSet::new();
        for _ in 0..num_old_ids {
            let pk = Keypair::new().pubkey();
            old_ids.insert(pk);
            leader_scheduler.push_vote(pk, start_height);
        }

        // Insert a bunch of votes at height "start_height + ACTIVE_WINDOW"
        let num_new_ids = 10;
        let mut new_ids = HashSet::new();
        for _ in 0..num_new_ids {
            let pk = Keypair::new().pubkey();
            new_ids.insert(pk);
            leader_scheduler.push_vote(pk, start_height + ACTIVE_WINDOW);
        }

        let all_ids = old_ids.union(&new_ids).collect();

        // Queries for the active set
        let result = leader_scheduler.get_active_set(ACTIVE_WINDOW + start_height - 1);
        assert_eq!(result.len(), num_old_ids + num_new_ids);
        let result_set = to_hashset(&result);
        assert_eq!(result_set, all_ids);

        let result = leader_scheduler.get_active_set(ACTIVE_WINDOW + start_height);
        assert_eq!(result.len(), num_new_ids);
        let result_set = to_hashset_owned(&result);
        assert_eq!(result_set, new_ids);

        let result = leader_scheduler.get_active_set(2 * ACTIVE_WINDOW + start_height - 1);
        assert_eq!(result.len(), num_new_ids);
        let result_set = to_hashset_owned(&result);
        assert_eq!(result_set, new_ids);

        let result = leader_scheduler.get_active_set(2 * ACTIVE_WINDOW + start_height);
        assert_eq!(result.len(), 0);
        let result_set = to_hashset_owned(&result);
        assert!(result_set.is_empty());
    }

    #[test]
    fn test_seed() {
        // Check that num_seeds different seeds are  generated
        let num_seeds = 1000;
        let mut old_seeds = HashSet::new();
        for i in 0..num_seeds {
            let seed = LeaderScheduler::calculate_seed(i);
            assert!(!old_seeds.contains(&seed));
            old_seeds.insert(seed);
        }
    }

    #[test]
    fn test_rank_active_set() {
        let num_validators: usize = 101;
        // Give mint sum(1..num_validators) tokens
        let mint = Mint::new((((num_validators + 1) / 2) * (num_validators + 1)) as i64);
        let bank = Bank::new(&mint);
        let mut validators = vec![];
        let last_id = mint
            .create_entries()
            .last()
            .expect("Mint should not create empty genesis entries")
            .id;
        for i in 0..num_validators {
            let new_validator = Keypair::new();
            let new_pubkey = new_validator.pubkey();
            validators.push(new_validator);
            bank.transfer(
                (num_validators - i) as i64,
                &mint.keypair(),
                new_pubkey,
                last_id,
            ).unwrap();
        }

        let mut result = LeaderScheduler::rank_active_set(
            &bank,
            validators.iter().map(Keypair::pubkey).collect(),
        );
        assert_eq!(result.len(), validators.len());

        // Expect the result to be the reverse of the list we passed into the rank_active_set()
        for (i, (pk, balance)) in result.iter().enumerate() {
            assert_eq!(*balance, i as u64 + 1);
            assert_eq!(*pk, validators[num_validators - i - 1].pubkey());
        }

        // Transfer all the tokens to a new set of validators, old validators should now
        // have balance of zero and get filtered out of the rankings
        let mut new_validators = vec![];
        for i in 0..num_validators {
            let new_validator = Keypair::new();
            let new_pubkey = new_validator.pubkey();
            new_validators.push(new_validator);
            bank.transfer(
                (num_validators - i) as i64,
                &validators[i],
                new_pubkey,
                last_id,
            ).unwrap();
        }

        let all_validators: Vec<Pubkey> = validators
            .iter()
            .chain(new_validators.iter())
            .map(Keypair::pubkey)
            .collect();
        result = LeaderScheduler::rank_active_set(&bank, all_validators.clone());
        assert_eq!(result.len(), new_validators.len());

        for (i, (pk, balance)) in result.iter().enumerate() {
            assert_eq!(*balance, i as u64 + 1);
            assert_eq!(*pk, new_validators[num_validators - i - 1].pubkey());
        }

        // Break ties between validators with the same balances using public key
        let mint = Mint::new(num_validators as i64);
        let bank = Bank::new(&mint);
        let mut tied_validators_pk = vec![];
        let last_id = mint
            .create_entries()
            .last()
            .expect("Mint should not create empty genesis entries")
            .id;

        for _ in 0..num_validators {
            let new_validator = Keypair::new();
            let new_pubkey = new_validator.pubkey();
            tied_validators_pk.push(new_pubkey);
            bank.transfer(1, &mint.keypair(), new_pubkey, last_id)
                .unwrap();
        }

        result = LeaderScheduler::rank_active_set(&bank, tied_validators_pk.clone());
        tied_validators_pk.sort_by(|pk1, pk2| pk1.cmp(pk2));
        assert_eq!(result.len(), tied_validators_pk.len());
        for (i, (pk, t)) in result.iter().enumerate() {
            assert_eq!(*t, 1);
            assert_eq!(*pk, tied_validators_pk[i]);
        }
    }

    #[test]
    fn test_choose_account() {
        let tokens = vec![10, 30, 50, 5, 1];
        let total_tokens = tokens.iter().sum();
        let mut seed = tokens[0];
        assert_eq!(
            LeaderScheduler::choose_account(tokens.clone(), seed, total_tokens),
            1
        );

        seed = tokens[0] - 1;
        assert_eq!(
            LeaderScheduler::choose_account(tokens.clone(), seed, total_tokens),
            0
        );

        seed = 0;
        assert_eq!(
            LeaderScheduler::choose_account(tokens.clone(), seed, total_tokens),
            0
        );

        seed = total_tokens;
        assert_eq!(
            LeaderScheduler::choose_account(tokens.clone(), seed, total_tokens),
            0
        );

        seed = total_tokens - 1;
        assert_eq!(
            LeaderScheduler::choose_account(tokens.clone(), seed, total_tokens),
            tokens.len() - 1
        );

        seed = tokens[0..3].iter().sum();
        assert_eq!(
            LeaderScheduler::choose_account(tokens.clone(), seed, total_tokens),
            3
        );
    }

    fn run_scheduler_test(
        num_validators: usize,
        bootstrap_entry_height: u64,
        leader_rotation_interval: u64,
        seed_rotation_interval: u64,
    ) {
        if num_validators == 0 {
            return;
        }

        // Set up the LeaderScheduler struct
        let bootstrap_leader_id = Keypair::new().pubkey();
        let mut leader_scheduler = LeaderScheduler::new(
            bootstrap_leader_id,
            Some(bootstrap_entry_height),
            Some(leader_rotation_interval),
            Some(seed_rotation_interval),
        );

        // Create the bank and validators, which are inserted in order of account balance
        let mint = Mint::new((((num_validators + 1) / 2) * (num_validators + 1)) as i64);
        let bank = Bank::new(&mint);
        let mut validators = vec![];
        let last_id = mint
            .create_entries()
            .last()
            .expect("Mint should not create empty genesis entries")
            .id;
        for i in 0..num_validators {
            let new_validator = Keypair::new();
            let new_pubkey = new_validator.pubkey();
            validators.push(new_pubkey);
            // Make the validator part of the active set for the entire test
            leader_scheduler.push_vote(new_pubkey, 1);
            bank.transfer((i + 1) as i64, &mint.keypair(), new_pubkey, last_id)
                .unwrap();
        }

        // The scheduled leader during the bootstrapping period should always be the
        // bootstrap leader
        assert_eq!(
            leader_scheduler.get_scheduled_leader(0),
            Some(bootstrap_leader_id)
        );
        assert_eq!(
            leader_scheduler.get_scheduled_leader(bootstrap_entry_height - 1),
            Some(bootstrap_leader_id)
        );
        assert_eq!(
            leader_scheduler.get_scheduled_leader(bootstrap_entry_height),
            None
        );

        // Generate the schedule at the end of the bootstrapping period, should be the
        // same leader for the next leader_rotation_interval entries
        leader_scheduler.generate_schedule(bootstrap_entry_height, &bank);

        // The leader outside of the window [bootstrap_entry_height, bootstrap_entry_height + seed_rotation_interval]
        // should be unknown
        assert_eq!(
            leader_scheduler.get_scheduled_leader(bootstrap_entry_height - 1),
            None,
        );

        assert_eq!(
            leader_scheduler.get_scheduled_leader(bootstrap_entry_height + seed_rotation_interval),
            None,
        );

        // For the next seed_rotation_interval entries, call get_scheduled_leader every
        // leader_rotation_interval entries, and the next leader should be the next validator
        // in order of stake
        let mut current_leader = leader_scheduler
            .get_scheduled_leader(bootstrap_entry_height)
            .expect("Expected a leader from scheduler");

        let first_index = validators
            .iter()
            .position(|v| *v == current_leader)
            .unwrap();

        // seed_rotation_interval must be divisible by leader_rotation_interval, enforced
        // by the LeaderScheduler constructor
        let num_rounds = seed_rotation_interval / leader_rotation_interval;

        for i in 1..num_rounds {
            let begin_height = bootstrap_entry_height + i * leader_rotation_interval;
            current_leader = leader_scheduler
                .get_scheduled_leader(begin_height)
                .expect("Expected a leader from scheduler");
            let expected_leader = validators[(first_index + i as usize) % num_validators];
            assert_eq!(current_leader, expected_leader);
            // Check that the same leader is in power for the next leader_rotation_interval entries
            assert_eq!(
                leader_scheduler.get_scheduled_leader(begin_height + leader_rotation_interval - 1),
                Some(current_leader)
            );
        }
    }

    #[test]
    fn test_scheduler() {
        let mut num_validators = 100;
        let mut bootstrap_entry_height = 500;
        let mut leader_rotation_interval = 100;
        let mut seed_rotation_interval = leader_rotation_interval * num_validators;
        run_scheduler_test(
            num_validators,
            bootstrap_entry_height,
            leader_rotation_interval as u64,
            seed_rotation_interval as u64,
        );

        num_validators = 3;
        bootstrap_entry_height = 500;
        leader_rotation_interval = 100;
        seed_rotation_interval = 1000;
        run_scheduler_test(
            num_validators,
            bootstrap_entry_height,
            leader_rotation_interval as u64,
            seed_rotation_interval as u64,
        );

        num_validators = 10;
        bootstrap_entry_height = 500;
        leader_rotation_interval = 100;
        seed_rotation_interval = 200;
        run_scheduler_test(
            num_validators,
            bootstrap_entry_height,
            leader_rotation_interval as u64,
            seed_rotation_interval as u64,
        );

        num_validators = 10;
        bootstrap_entry_height = 1;
        leader_rotation_interval = 1;
        seed_rotation_interval = 2;
        run_scheduler_test(
            num_validators,
            bootstrap_entry_height,
            leader_rotation_interval as u64,
            seed_rotation_interval as u64,
        );
    }
}
